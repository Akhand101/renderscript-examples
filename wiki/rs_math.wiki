#summary API specification of rs_math.rsh

= Introduction =

API specification of rs_math.rsh


= Details =

|| *Function* || *Description* ||
|| void rsSetObject(rs_element `*`dst, rs_element src);<br>void rsSetObject(rs_type `*`dst, rs_type src);<br>void rsSetObject(rs_allocation `*`dst, rs_allocation src);<br>void rsSetObject(rs_sampler `*`dst, rs_sampler src);<br>void rsSetObject(rs_script `*`dst, rs_script src);<br>void rsSetObject(rs_mesh `*`dst, rs_mesh src);<br>void rsSetObject(rs_program_fragment `*`dst, rs_program_fragment src);<br>void rsSetObject(rs_program_vertex `*`dst, rs_program_vertex src);<br>void rsSetObject(rs_program_raster `*`dst, rs_program_raster src);<br>void rsSetObject(rs_program_store `*`dst, rs_program_store src);<br>void rsSetObject(rs_font `*`dst, rs_font src); || Copy reference to the specified object. ||
|| void rsClearObject(rs_element `*`dst);<br>void rsClearObject(rs_type `*`dst);<br>void rsClearObject(rs_allocation `*`dst);<br>void rsClearObject(rs_sampler `*`dst);<br>void rsClearObject(rs_script `*`dst);<br>void rsClearObject(rs_mesh `*`dst);<br>void rsClearObject(rs_program_fragment `*`dst);<br>void rsClearObject(rs_program_vertex `*`dst);<br>void rsClearObject(rs_program_raster `*`dst);<br>void rsClearObject(rs_program_store `*`dst);<br>void rsClearObject(rs_font `*`dst); || Sets the object to NULL. ||
|| bool rsIsObject(rs_element);<br>bool rsIsObject(rs_type);<br>bool rsIsObject(rs_allocation);<br>bool rsIsObject(rs_sampler);<br>bool rsIsObject(rs_script);<br>bool rsIsObject(rs_mesh);<br>bool rsIsObject(rs_program_fragment);<br>bool rsIsObject(rs_program_vertex);<br>bool rsIsObject(rs_program_raster);<br>bool rsIsObject(rs_program_store);<br>bool rsIsObject(rs_font); || Tests if the object is valid.  Returns true if the object is valid, false if it is NULL. ||
|| rs_allocation rsGetAllocation(const void `*`); || Returns the Allocation for a given pointer.<br>The pointer should point within a valid allocation.<br>The results are undefined if the pointer is not from a valid allocation. ||
|| uint32_t rsAllocationGetDimX(rs_allocation); ||Query the dimension of an allocation. ||
|| uint32_t rsAllocationGetDimY(rs_allocation); || Query the dimension of an allocation. ||
|| uint32_t rsAllocationGetDimZ(rs_allocation); || Query the dimension of an allocation. ||
|| uint32_t rsAllocationGetDimLOD(rs_allocation); || Query an allocation for the presence of more than one LOD. ||
|| uint32_t rsAllocationGetDimFaces(rs_allocation); || Query an allocation for the presence of more than one face. ||
|| void`*` rsGetElementAt(rs_allocation, uint32_t x);<br>void`*` rsGetElementAt(rs_allocation, uint32_t x, uint32_t y);<br>void`*` rsGetElementAt(rs_allocation, uint32_t x, uint32_t y, uint32_t z); || Extract a single element from an allocation. ||
|| int rsRand(int max_value);<br>int rsRand(int min_value, int max_value);<br>int rsRand(float max_value);<br>float rsRand(float min_value, float max_value); || Return a random value between 0 (or min_value) and max_malue. ||
|| float rsFrac(float); || return the fractional part of a float<br>min(v - ((int)floor(v)), 0x1.fffffep-1f); ||
|| bool rsSendToClient(int cmdID);<br>bool rsSendToClient(int cmdID, const void `*`data, uint len); || Send a message back to the client.<br>Will not block and returns true if the message was sendable and false if the fifo was full.<br>A message ID is required.  Data payload is optional.||
|| void rsSendToClientBlocking(int cmdID);<br>void rsSendToClientBlocking(int cmdID, const void `*`data, uint len); || Send a message back to the client, blocking until the message is queued.<br>A message ID is required.  Data payload is optional. ||
|| void rsForEach(rs_script script, rs_allocation input,<br>rs_allocation output, const void `*`usrData);<br>void rsForEach(rs_script script, rs_allocation input,<br>rs_allocation output, const void `*`usrData, const rs_script_call_t `*`); || ||